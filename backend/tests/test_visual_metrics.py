"""
Unit tests for visual metrics computation.
"""

import pytest
import numpy as np
from src.visual_metrics import LossVisualMetrics  # noqa: E402


def _compute_runtime_metrics(
    runtime_core, image: np.ndarray, c: complex
):
    if image.max() > 1.0:
        image = image.astype(np.float64) / 255.0
    height, width = image.shape[:2]
    channels = 1 if image.ndim == 2 else image.shape[2]
    flat = image.astype(np.float64).reshape(-1).tolist()
    return runtime_core.compute_runtime_visual_metrics(
        flat, width, height, channels, c, 50
    )


class TestLossVisualMetrics:
    """Test loss-only visual metrics computation."""

    def test_metrics_initialization(self):
        """Test creating LossVisualMetrics instance."""
        metrics = LossVisualMetrics()
        assert metrics is not None

    def test_temporal_change(self):
        """Test temporal change metric between frames."""
        metrics_calc = LossVisualMetrics()

        image1 = np.random.rand(64, 64).astype(np.float32)
        image2 = image1 + np.random.randn(64, 64).astype(np.float32) * 0.1

        results = metrics_calc.compute_all_metrics(image2, prev_image=image1)

        assert "temporal_change" in results
        assert results["temporal_change"] > 0.0
        assert results["temporal_change"] < 1.0

    def test_render_julia_set(self):
        """Test Julia set rendering."""
        metrics_calc = LossVisualMetrics()

        image = metrics_calc.render_julia_set(
            seed=-0.7 + 0.27j, width=128, height=128, zoom=1.0
        )

        assert image.shape == (128, 128, 3)
        assert image.dtype == np.uint8
        assert image.min() >= 0
        assert image.max() <= 255


class TestRuntimeVisualMetrics:
    """Test Rust-backed runtime visual metrics."""

    def test_runtime_metrics_ranges(self, runtime_core_module):
        """Ensure runtime metrics are computed and within expected ranges."""
        image = np.random.rand(32, 32, 3).astype(np.float32)
        metrics = _compute_runtime_metrics(runtime_core_module, image, 0.0 + 0.0j)

        assert 0.0 <= metrics.edge_density <= 1.0
        assert 0.0 <= metrics.color_uniformity <= 1.0
        assert 0.0 <= metrics.brightness_mean <= 1.0
        assert metrics.brightness_std >= 0.0
        assert 0.0 <= metrics.brightness_range <= 1.0
        assert metrics.mandelbrot_membership is True

    def test_mandelbrot_membership_outside(self, runtime_core_module):
        """Ensure membership returns False for an escaping point."""
        image = np.zeros((8, 8), dtype=np.float32)
        metrics = _compute_runtime_metrics(runtime_core_module, image, 2.0 + 0.0j)
        assert metrics.mandelbrot_membership is False


@pytest.mark.parametrize(
    "c_real,c_imag, nominal_distance",
    [
        (0.0, 0.0, 0.25),  # origin is nearest the cardioid's "buttcrack" at 0.25
        (2.0, 0.0, 1.57044),  # Nearest the "buttcheecks"
        (0.25, 0.0, 0.0),  # on the boundary (of the main cardioid)
        (0.4439, 0.2117, 0.0),  # on the boundary (near bulb)
        (-0.1011, 0.6330, 0.0),  # on the boundary (near top bulb)
    ],
)
def test_mandelbrot_distance_estimate(c_real, c_imag, nominal_distance):
    """Ensure sampling matches the precomputed field generated by the fixture."""
    import torch

    # Test the sampler
    c_complex = torch.tensor([c_real + 1j * c_imag], dtype=torch.complex64)
    res = LossVisualMetrics.mandelbrot_distance_estimate(c_complex)
    calculated_distance = res.item()
    tol = 0.02
    assert res.shape == (1,)
    assert torch.isfinite(res).all()
    assert calculated_distance >= 0.0, "Distance should be non-negative"
    assert abs(calculated_distance - nominal_distance) < tol, (
        f"Distance estimate {calculated_distance} differs from expected "
        f"{nominal_distance} by more than tolerance."
    )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
