"""
Unit tests for visual metrics computation.
"""

import pytest
import numpy as np
import sys
from pathlib import Path
import subprocess

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.visual_metrics import LossVisualMetrics  # noqa: E402


@pytest.fixture(scope="module")
def distance_field(tmp_path_factory):
    """Prefer a prebuilt distance field (env var FRACSYNC_DISTFIELD or data/) otherwise build one once for the module."""
    # 1) explicit path via env var
    import os

    env_path = os.environ.get("FRACSYNC_DISTFIELD")
    if env_path:
        p = Path(env_path)
        if p.exists():
            from src.visual_metrics import load_distance_field

            load_distance_field(p)
            return p

    # 2) look for a canonical file in data/
    candidates = [
        Path("data/mandelbrot_distance_2048.npy"),
        Path("data/mandelbrot_distance_1024.npy"),
        Path("data/mandelbrot_distance.npy"),
    ]
    for p in candidates:
        if p.exists():
            from src.visual_metrics import load_distance_field

            load_distance_field(p)
            return p

    # 3) fallback: build a modest field once for tests
    base = tmp_path_factory.mktemp("distfield")
    out = base / "distfield"
    out_npy = out.with_suffix(".npy")
    cmd = [
        sys.executable,
        "scripts/build_distance_field.py",
        "--out",
        str(out_npy),
        "--res",
        "1024",
        "--xmin",
        "-2.5",
        "--xmax",
        "1.5",
        "--ymin",
        "-2.0",
        "--ymax",
        "2.0",
        "--max-iter",
        "1024",
    ]
    subprocess.check_call(cmd)

    from src.visual_metrics import load_distance_field

    load_distance_field(out_npy)
    return out_npy


def _compute_runtime_metrics(
    runtime_core, image: np.ndarray, c_real: float, c_imag: float
):
    if image.max() > 1.0:
        image = image.astype(np.float64) / 255.0
    height, width = image.shape[:2]
    channels = 1 if image.ndim == 2 else image.shape[2]
    flat = image.astype(np.float64).reshape(-1).tolist()
    return runtime_core.compute_runtime_visual_metrics(
        flat, width, height, channels, c_real, c_imag, 50
    )


class TestLossVisualMetrics:
    """Test loss-only visual metrics computation."""

    def test_metrics_initialization(self):
        """Test creating LossVisualMetrics instance."""
        metrics = LossVisualMetrics()
        assert metrics is not None

    def test_temporal_change(self):
        """Test temporal change metric between frames."""
        metrics_calc = LossVisualMetrics()

        image1 = np.random.rand(64, 64).astype(np.float32)
        image2 = image1 + np.random.randn(64, 64).astype(np.float32) * 0.1

        results = metrics_calc.compute_all_metrics(image2, prev_image=image1)

        assert "temporal_change" in results
        assert results["temporal_change"] > 0.0
        assert results["temporal_change"] < 1.0

    def test_render_julia_set(self):
        """Test Julia set rendering."""
        metrics_calc = LossVisualMetrics()

        image = metrics_calc.render_julia_set(
            seed_real=-0.7, seed_imag=0.27, width=128, height=128, zoom=1.0
        )

        assert image.shape == (128, 128, 3)
        assert image.dtype == np.uint8
        assert image.min() >= 0
        assert image.max() <= 255


class TestRuntimeVisualMetrics:
    """Test Rust-backed runtime visual metrics."""

    def test_runtime_metrics_ranges(self, runtime_core_module):
        """Ensure runtime metrics are computed and within expected ranges."""
        image = np.random.rand(32, 32, 3).astype(np.float32)
        metrics = _compute_runtime_metrics(runtime_core_module, image, 0.0, 0.0)

        assert 0.0 <= metrics.edge_density <= 1.0
        assert 0.0 <= metrics.color_uniformity <= 1.0
        assert 0.0 <= metrics.brightness_mean <= 1.0
        assert metrics.brightness_std >= 0.0
        assert 0.0 <= metrics.brightness_range <= 1.0
        assert metrics.mandelbrot_membership is True

    def test_mandelbrot_membership_outside(self, runtime_core_module):
        """Ensure membership returns False for an escaping point."""
        image = np.zeros((8, 8), dtype=np.float32)
        metrics = _compute_runtime_metrics(runtime_core_module, image, 2.0, 0.0)
        assert metrics.mandelbrot_membership is False


@pytest.mark.parametrize(
    "c_real,c_imag, expected_distance",
    [
        (0.0, 0.0, 0.25),  # origin is nearest the cardoid's "buttcrack" at 0.25
        (2.0, 0.0, 1.57044),  # Nearest the "buttcheecks"
        (0.25, 0.0, 0),  # on the boundary (of the main cardioid)
        (0.4439, 0.2117, 0.0),  # on the boundary (near bulb)
        (-0.1011, 0.6330, 0.0),  # on the boundary (near top bulb)
    ],
)
def test_mandelbrot_distance_estimate(
    c_real, c_imag, expected_distance, distance_field
):
    """Ensure sampling matches the precomputed field generated by the fixture."""
    import torch

    out_npy = distance_field

    # Test the sampler
    c_complex = torch.tensor([c_real + 1j * c_imag], dtype=torch.complex64)
    res = LossVisualMetrics.mandelbrot_distance_estimate(c_complex)
    calculated_distance = res.item()

    assert res.shape == (1,)
    assert torch.isfinite(res).all()
    assert calculated_distance >= 0.0, "Distance should be non-negative"

    # Compare with raw field value at the mapped pixel
    arr = np.load(out_npy)
    H, W = arr.shape
    xmin, xmax, ymin, ymax = -2.5, 1.5, -2.0, 2.0
    u = (c_real - xmin) / (xmax - xmin)
    v = (c_imag - ymin) / (ymax - ymin)
    x = int(u * (W - 1))
    y = int(v * (H - 1))
    # clamp pixel coords to field extents (sampling uses border padding)
    x = max(0, min(x, W - 1))
    y = max(0, min(y, H - 1))
    expected_field = abs(float(arr[y, x]))

    # tolerance is a couple of pixels worth
    pixel_scale = ((xmax - xmin) ** 2 + (ymax - ymin) ** 2) ** 0.5 / float(1024)
    tol = max(1e-6, 3.0 * pixel_scale)
    assert (
        abs(calculated_distance - expected_field) <= tol
    ), f"field mismatch at ({c_real},{c_imag}): sample={calculated_distance} field={expected_field} tol={tol}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
